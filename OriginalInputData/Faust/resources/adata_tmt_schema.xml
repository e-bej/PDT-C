<?xml version="1.0"?>
<!--
  Created by pml_simplify on Thu Feb 18 15:30:53 2010
  Command-line: pml_simlify adata_tmt_schema.derived.xml
-->
<pml_schema xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/" xmlns:s="http://ufal.mff.cuni.cz/pdt/pml/schema/" version="1.1">
  <revision>0.1</revision>
  <description>PDT tdata extended by tmt a-node attrs</description>
  <!--  ============ import schema="http://ufal.mff.cuni.cz/jazz/PML/schemas/adata_schema.xml" ============  -->
  <root name="adata" type="a-adata.type"/>
  <type name="m-form_change.type">
    <list ordered="0">
      <choice>
        <value>ctcd</value>
        <value>spell</value>
        <value>insert</value>
        <value>num_normalization</value>
      </choice>
    </list>
  </type>
  <type name="w-node.type">
    <structure name="w-node">
      <member as_attribute="1" name="id" role="#ID" required="1">
        <cdata format="PMLREF"/>
      </member>
      <member name="token" required="1">
        <cdata format="any"/>
      </member>
      <member name="no_space_after" type="bool.type"/>
    </structure>
  </type>
  <type name="a-adata.type">
    <structure>
      <member name="meta" required="0" type="a-meta.type"/>
      <member name="trees" role="#TREES" required="1">
        <list type="a-root.type" ordered="1"/>
      </member>
    </structure>
  </type>
  <type name="a-meta.type">
    <structure>
      <member name="annotation_info">
        <structure name="a-annotation-info">
          <member name="version_info">
            <cdata format="any"/>
          </member>
          <member name="desc">
            <cdata format="any"/>
          </member>
        </structure>
      </member>
    </structure>
  </type>
  <type name="a-root.type">
    <structure role="#NODE" name="a-root">
      <member name="id" role="#ID" as_attribute="1" required="1">
        <cdata format="ID"/>
      </member>
      <member name="s.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="afun">
        <constant>AuxS</constant>
      </member>
      <member name="ord" role="#ORDER" required="1">
        <cdata format="nonNegativeInteger"/>
      </member>
      <member name="children" role="#CHILDNODES">
        <list type="a-node.type" ordered="1"/>
      </member>
    </structure>
  </type>
  <!--  ============ derived from a-node.type ============  -->
  <type name="a-node.type">
    <structure role="#NODE" name="a-node">
      <member name="id" role="#ID" as_attribute="1" required="1">
        <cdata format="ID"/>
      </member>
      <member name="m.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="afun" type="afun.type"/>
      <member name="is_member" type="bool.type"/>
      <member type="bool.type" name="is_parenthesis_root"/>
      <member name="ord" role="#ORDER" required="1">
        <cdata format="nonNegativeInteger"/>
      </member>
      <member name="m" type="m-node.type"/>
      <member name="functions">
        <list type="p-function.type" ordered="1"/>
      </member>
      <member name="p" type="a-p.type"/>
      <member type="bool.type" name="is_aux_to_child"/>
      <member type="bool.type" name="is_aux_to_parent"/>
      <member type="bool.type" name="parent_is_aux"/>
      <member type="bool.type" name="edge_to_collapse"/>
      <member type="bool.type" name="is_auxiliary"/>
      <member name="conll_deprel">
        <cdata format="any"/>
      </member>
      <member type="bool.type" name="is_clause_head"/>
      <member name="morphcat" type="czech_morphcat.type"/>
      <member name="clause_number">
        <cdata format="any"/>
      </member>
      <member name="is_indeclinable" type="bool.type"/>
      <member name="delayed_reorder">
        <structure>
          <member name="non_projective_shift_to_leftmost_of">
            <cdata format="any"/>
          </member>
        </structure>
      </member>
      <member name="coref" type="a_coreference.type"/>
      <member name="children" role="#CHILDNODES">
        <list type="a-node.type" ordered="1"/>
      </member>
    </structure>
  </type>
  <type name="a-afun.type">
    <choice>
      <value>Pred</value>
      <value>Pnom</value>
      <value>AuxV</value>
      <value>Sb</value>
      <value>Obj</value>
      <value>Atr</value>
      <value>Adv</value>
      <value>AtrAdv</value>
      <value>AdvAtr</value>
      <value>Coord</value>
      <value>AtrObj</value>
      <value>ObjAtr</value>
      <value>AtrAtr</value>
      <value>AuxT</value>
      <value>AuxR</value>
      <value>AuxP</value>
      <value>Apos</value>
      <value>ExD</value>
      <value>AuxC</value>
      <value>Atv</value>
      <value>AtvV</value>
      <value>AuxO</value>
      <value>AuxZ</value>
      <value>AuxY</value>
      <value>AuxG</value>
      <value>AuxK</value>
      <value>AuxX</value>
    </choice>
  </type>
  <!--  ===================================================================================================  -->
  <type name="m-node.type">
    <structure name="m-node" role="#NODE">
      <member name="id" as_attribute="1" role="#ID" required="0">
        <cdata format="ID"/>
      </member>
      <!--      <member name="src.rf"><cdata format="PMLREF"/></member>
      <member name="w.rf">
        <list ordered="1" role="#KNIT" type="w-node.type"/>
      </member> -->
      <member name="form_change" type="m-form_change.type">
        <!--        <choice>
          <value>ctcd</value>
          <value>spell</value>
          <value>insert</value>
          <value>num_normalization</value>
        </choice> -->
      </member>
      <!--
        Offset is position (starting with 0) of the first character of the form in the source sentence.
        It is needed for late sentence segmentation.
        (20.6.2008 zeman)
      -->
      <member name="offset">
        <cdata format="any"/>
      </member>
      <member name="form">
        <cdata format="any"/>
      </member>
      <!--
        Form transliterated to another script. Typically the target script is Latin
        and transliteration means romanization.
      -->
      <member name="translit">
        <cdata format="any"/>
      </member>
      <member name="lemma">
        <cdata format="any"/>
      </member>
      <member name="tag">
        <cdata format="any"/>
      </member>
      <member name="gloss">
        <cdata format="any"/>
      </member>
      <!--
        2.1.2008 ptacek: need this for get_sentence_string()
      -->
      <member name="w">
        <list ordered="1">
          <structure name="w-node">
            <member name="token">
              <cdata format="any"/>
            </member>
            <member name="no_space_after" type="bool.type"/>
          </structure>
        </list>
      </member>
      <!--
        8.2.2010 ptacek: no_space_after temporarily allowed 
        so data generated by pdt-to-tmt before continue to be valid
        (please rerun your conversions)
      -->
      <member name="no_space_after" type="bool.type"/>
      <member name="align">
        <structure>
          <member name="giza_links">
            <list ordered="0" type="align-links.type"/>
          </member>
          <member name="links">
            <list ordered="0" type="align-links.type"/>
          </member>
          <member name="manual_links">
            <list ordered="0" type="align-links.type"/>
          </member>
        </structure>
      </member>
    </structure>
  </type>
  <type name="afun.type">
    <choice>
      <value>Pred</value>
      <value>Pnom</value>
      <value>AuxV</value>
      <value>Sb</value>
      <value>Obj</value>
      <value>Atr</value>
      <value>Adv</value>
      <value>AtrAdv</value>
      <value>AdvAtr</value>
      <value>Coord</value>
      <value>AtrObj</value>
      <value>ObjAtr</value>
      <value>AtrAtr</value>
      <value>AuxT</value>
      <value>AuxR</value>
      <value>AuxP</value>
      <value>Apos</value>
      <value>ExD</value>
      <value>AuxC</value>
      <value>Atv</value>
      <value>AtvV</value>
      <value>AuxO</value>
      <value>AuxZ</value>
      <value>AuxY</value>
      <value>AuxG</value>
      <value>AuxK</value>
      <value>AuxX</value>
      <!-- afun for articles/determiners used in en_generate. ptacek 2008 -->
      <value>Det</value>
      <!-- afun for English articles "a", "an", "the" (used in SEnglishM_to_SEnglishA).
           Other determiners (this,each,any,some,every,no... PennTag=DT) have usually afun Atr. Popel 9.5.2009 -->
      <value>AuxA</value>
      <!-- afun for english negation "not". On PDT-like t-layer it should be #Neg node, so it's not auxiliary, I think. Popel 9.5.2009 -->
      <value>Neg</value>
      <!-- values added because of Prague Arabic Dependency Treebank -->
      <value>AuxM</value>
      <value>AuxE</value>
      <value>Ante</value>
      <!-- afun for unrecognized value -->
      <value>NR</value>
    </choice>
  </type>
  <type name="bool.type">
    <choice>
      <value>0</value>
      <value>1</value>
    </choice>
  </type>
  <type name="p-function.type">
    <choice>
      <value>ADV</value>
      <value>NOM</value>
      <value>DTV</value>
      <value>LGS</value>
      <value>PRD</value>
      <value>PUT</value>
      <value>SBJ</value>
      <value>TPC</value>
      <value>VOC</value>
      <value>BNF</value>
      <value>DIR</value>
      <value>EXT</value>
      <value>LOC</value>
      <value>MNR</value>
      <value>PRP</value>
      <value>TMP</value>
      <value>CLR</value>
      <value>CLF</value>
      <value>HLN</value>
      <value>TTL</value>
    </choice>
  </type>
  <type name="a-p.type">
    <!-- pridano na navrh Jirky -->
    <structure>
      <member name="terminal.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="nonterminals.rf">
        <list ordered="0">
          <cdata format="PMLREF"/>
        </list>
      </member>
    </structure>
  </type>
  <type name="czech_morphcat.type">
    <structure>
      <member name="pos">
        <cdata format="any"/>
      </member>
      <member name="subpos">
        <cdata format="any"/>
      </member>
      <member name="synpos">
        <cdata format="any"/>
      </member>
      <member name="gender">
        <cdata format="any"/>
      </member>
      <member name="number">
        <cdata format="any"/>
      </member>
      <member name="case">
        <cdata format="any"/>
      </member>
      <member name="possgender">
        <cdata format="any"/>
      </member>
      <member name="possnumber">
        <cdata format="any"/>
      </member>
      <member name="person">
        <cdata format="any"/>
      </member>
      <member name="tense">
        <cdata format="any"/>
      </member>
      <member name="grade">
        <cdata format="any"/>
      </member>
      <member name="negation">
        <cdata format="any"/>
      </member>
      <member name="voice">
        <cdata format="any"/>
      </member>
      <member name="reserve1">
        <cdata format="any"/>
      </member>
      <member name="reserve2">
        <cdata format="any"/>
      </member>
      <!-- ptacek 5.8.2008 for en/cz_generate -->
      <member name="compound_person">
        <cdata format="any"/>
      </member>
      <member name="compound_number">
        <cdata format="any"/>
      </member>
      <member name="compound_gender">
        <cdata format="any"/>
      </member>
      <member name="ordering_type">
        <cdata format="any"/>
      </member>
      <!-- zabokrtsky because of Arabic -->
      <member name="definiteness">
        <cdata format="any"/>
      </member>
      <member name="mood">
        <cdata format="any"/>
      </member>
    </structure>
  </type>
  <type name="a_coreference.type">
    <!-- analyticka koreference pro Jirku Mirovskeho -->
    <structure>
      <member name="markable" type="bool.type"/>
      <!-- a token to be considered as anaphor/antecedent -->
      <member name="introduction" type="bool.type"/>
      <!-- first introduction of the entity to the discourse -->
      <member name="anaphor_type">
        <cdata format="any"/>
      </member>
      <!-- the type of the anaphor - pronoun, proper_noun, demonstrative_noun_phrase, common_noun -->
      <member name="target-node.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="type">
        <cdata format="any"/>
      </member>
      <member name="src">
        <cdata format="any"/>
      </member>
    </structure>
  </type>
  <type name="align-links.type">
    <structure>
      <member name="counterpart.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="type">
        <cdata format="any"/>
      </member>
    </structure>
  </type>
</pml_schema>
